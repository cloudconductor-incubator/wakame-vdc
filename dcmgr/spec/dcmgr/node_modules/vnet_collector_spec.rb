# -*- coding: utf-8 -*-

require 'spec_helper'
require 'isono'

require 'helper_vnet_webmock'

describe Dcmgr::NodeModules::VnetCollector do

  before do
    extend_dcmgr_conf_for_openvnet
  end

  let(:vnet_collector) { Dcmgr::NodeModules::VnetCollector }

  let(:value_object) do
    double("value_object").tap do |v|
      allow(v).to receive(:copy_instance_variables).with( an_instance_of(Dcmgr::NodeModules::VnetCollector) ).and_return(true)
    end
  end

  let(:isono_node_mock) do
    double("isono_node").tap do |i|
      allow(i).to receive(:is_a?).and_return(Isono::Node)
      allow(i).to receive(:value_objects).twice.and_return({vnet_collector => value_object})
    end
  end

  let(:instance) { Fabricate(:instance_with_network_vif) }

  subject { vnet_collector.new(isono_node_mock) }

  describe "schedule_vifs(instance_uuid)" do
    it "sends network_vif params to create interface in vnet" do

      pending "since webmock does not allow to query with ':'"

      expected_retval = []
      instance.network_vif.each do |vif|
        if_uuid = vif.canonical_uuid.sub(/v/, '')

        params = {
          :uuid => if_uuid,
          :network_uuid => vif.network.canonical_uuid,
          :mac_address => vif.pretty_mac_addr,
          :ipv4_address => vif.ip.first.ipv4_s,
          :port_name => if_uuid
        }

        expected_retval << params[:uuid]

        stub_vnet_request("interfaces", params)
      end

      ret = subject.schedule_vifs(instance.canonical_uuid)
      expect(ret).to eq expected_retval
    end
  end
end
